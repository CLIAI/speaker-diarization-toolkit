#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "pyyaml>=6.0",
# ]
# ///
"""
speaker-process - Batch recording processing orchestrator

Orchestrate batch processing of recordings through the speaker-* pipeline:
transcription, speaker assignment, and catalog management.

Usage:
    speaker-process process <audio|directory> [OPTIONS]
    speaker-process status
    speaker-process queue <audio|directory> [OPTIONS]
    speaker-process run [--limit N]
    speaker-process clear-queue [--force]
"""

from __future__ import annotations

import argparse
import concurrent.futures
import json
import os
import subprocess
import sys
import threading
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Optional

# Optional YAML support
try:
    import yaml
    YAML_AVAILABLE = True
except ImportError:
    YAML_AVAILABLE = False


# =============================================================================
# Constants and Configuration
# =============================================================================

VERSION = "1.0.0"
SCHEMA_VERSION = 1

# Supported audio extensions
AUDIO_EXTENSIONS = {".wav", ".mp3", ".flac", ".m4a", ".ogg", ".opus", ".aac", ".wma"}

# Default backends for transcription
DEFAULT_BACKENDS = ["speechmatics", "assemblyai"]

# Queue item statuses
QUEUE_STATUS = ["pending", "processing", "completed", "failed", "skipped"]


def get_speakers_embeddings_dir() -> Path:
    """Get the root directory for speaker embeddings storage."""
    return Path(os.environ.get(
        "SPEAKERS_EMBEDDINGS_DIR",
        os.path.expanduser("~/.config/speakers_embeddings")
    ))


def get_queue_file() -> Path:
    """Get the path to the processing queue file."""
    queue_dir = get_speakers_embeddings_dir()
    queue_dir.mkdir(parents=True, exist_ok=True)
    return queue_dir / "process_queue.yaml"


def get_catalog_dir() -> Path:
    """Get the catalog directory."""
    return get_speakers_embeddings_dir() / "catalog"


# =============================================================================
# Utilities
# =============================================================================

def compute_b3sum(file_path: Path) -> str:
    """Compute Blake3 hash of a file, falling back to SHA256 if b3sum unavailable."""
    try:
        result = subprocess.run(
            ["b3sum", "--no-names", str(file_path)],
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout.strip()[:32]
    except (subprocess.CalledProcessError, FileNotFoundError):
        import hashlib
        sha256 = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(8192), b""):
                sha256.update(chunk)
        return sha256.hexdigest()[:32]


def utc_now_iso() -> str:
    """Return current UTC time in ISO format."""
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")


def load_yaml(path: Path) -> dict:
    """Load YAML file, with JSON fallback."""
    if not path.exists():
        return {}
    with open(path, "r") as f:
        content = f.read()
    if YAML_AVAILABLE:
        return yaml.safe_load(content) or {}
    else:
        return json.loads(content)


def save_yaml(path: Path, data: dict) -> None:
    """Save data as YAML, with JSON fallback."""
    with open(path, "w") as f:
        if YAML_AVAILABLE:
            yaml.dump(data, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
        else:
            json.dump(data, f, indent=2, ensure_ascii=False)


def is_audio_file(path: Path) -> bool:
    """Check if a path is an audio file based on extension."""
    return path.is_file() and path.suffix.lower() in AUDIO_EXTENSIONS


def find_audio_files(path: Path, recursive: bool = False) -> list[Path]:
    """Find all audio files in a directory."""
    if path.is_file():
        return [path] if is_audio_file(path) else []

    if not path.is_dir():
        return []

    if recursive:
        files = []
        for ext in AUDIO_EXTENSIONS:
            files.extend(path.rglob(f"*{ext}"))
        return sorted(files)
    else:
        return sorted([f for f in path.iterdir() if is_audio_file(f)])


def get_stt_command(backend: str) -> Optional[str]:
    """Get the STT command for a given backend."""
    commands = {
        "speechmatics": "stt_speechmatics.py",
        "assemblyai": "stt_assemblyai.py",
        "openai": "stt_openai.py",
        "whisper": "stt_openai_OR_local_whisper_cli.py",
    }
    return commands.get(backend)


def find_tool(name: str) -> Optional[Path]:
    """Find a tool in PATH or relative to this script."""
    # Check in PATH
    from shutil import which
    path_tool = which(name)
    if path_tool:
        return Path(path_tool)

    # Check relative to this script
    script_dir = Path(__file__).parent.resolve()
    relative_tool = script_dir / name
    if relative_tool.exists() and os.access(relative_tool, os.X_OK):
        return relative_tool

    return None


# =============================================================================
# Queue Management
# =============================================================================

@dataclass
class QueueItem:
    """A single item in the processing queue."""
    audio_path: str
    b3sum: str
    status: str = "pending"
    context: Optional[str] = None
    backends: list[str] = field(default_factory=list)
    queued_at: str = ""
    started_at: Optional[str] = None
    completed_at: Optional[str] = None
    error: Optional[str] = None
    results: dict = field(default_factory=dict)

    def to_dict(self) -> dict:
        return {
            "audio_path": self.audio_path,
            "b3sum": self.b3sum,
            "status": self.status,
            "context": self.context,
            "backends": self.backends,
            "queued_at": self.queued_at,
            "started_at": self.started_at,
            "completed_at": self.completed_at,
            "error": self.error,
            "results": self.results,
        }

    @staticmethod
    def from_dict(data: dict) -> "QueueItem":
        return QueueItem(
            audio_path=data.get("audio_path", ""),
            b3sum=data.get("b3sum", ""),
            status=data.get("status", "pending"),
            context=data.get("context"),
            backends=data.get("backends", []),
            queued_at=data.get("queued_at", ""),
            started_at=data.get("started_at"),
            completed_at=data.get("completed_at"),
            error=data.get("error"),
            results=data.get("results", {}),
        )


class ProcessingQueue:
    """Manage the processing queue."""

    def __init__(self):
        self.queue_file = get_queue_file()
        self._lock = threading.Lock()
        self._load()

    def _load(self) -> None:
        """Load queue from file."""
        data = load_yaml(self.queue_file)
        self.items: dict[str, QueueItem] = {}
        for item_data in data.get("items", []):
            item = QueueItem.from_dict(item_data)
            self.items[item.b3sum] = item
        self.schema_version = data.get("schema_version", SCHEMA_VERSION)

    def _save(self) -> None:
        """Save queue to file."""
        data = {
            "schema_version": SCHEMA_VERSION,
            "updated_at": utc_now_iso(),
            "items": [item.to_dict() for item in self.items.values()],
        }
        save_yaml(self.queue_file, data)

    def add(self, audio_path: Path, context: Optional[str] = None,
            backends: Optional[list[str]] = None) -> Optional[QueueItem]:
        """Add an item to the queue."""
        if not audio_path.exists():
            return None

        b3sum = compute_b3sum(audio_path)

        with self._lock:
            if b3sum in self.items:
                existing = self.items[b3sum]
                # Only update if not currently processing
                if existing.status != "processing":
                    existing.context = context or existing.context
                    existing.backends = backends or existing.backends
                    if existing.status in ("failed", "completed"):
                        existing.status = "pending"
                    self._save()
                return existing

            item = QueueItem(
                audio_path=str(audio_path.resolve()),
                b3sum=b3sum,
                context=context,
                backends=backends or DEFAULT_BACKENDS.copy(),
                queued_at=utc_now_iso(),
            )
            self.items[b3sum] = item
            self._save()
            return item

    def get_pending(self, limit: Optional[int] = None) -> list[QueueItem]:
        """Get pending items from the queue."""
        with self._lock:
            pending = [item for item in self.items.values() if item.status == "pending"]
            pending.sort(key=lambda x: x.queued_at)
            if limit:
                pending = pending[:limit]
            return pending

    def update_status(self, b3sum: str, status: str, error: Optional[str] = None,
                      results: Optional[dict] = None) -> None:
        """Update the status of a queue item."""
        with self._lock:
            if b3sum in self.items:
                item = self.items[b3sum]
                item.status = status
                if status == "processing":
                    item.started_at = utc_now_iso()
                elif status in ("completed", "failed", "skipped"):
                    item.completed_at = utc_now_iso()
                if error:
                    item.error = error
                if results:
                    item.results = results
                self._save()

    def remove(self, b3sum: str) -> bool:
        """Remove an item from the queue."""
        with self._lock:
            if b3sum in self.items:
                del self.items[b3sum]
                self._save()
                return True
            return False

    def clear(self, status_filter: Optional[str] = None) -> int:
        """Clear items from the queue."""
        with self._lock:
            if status_filter:
                to_remove = [k for k, v in self.items.items() if v.status == status_filter]
            else:
                to_remove = list(self.items.keys())

            for k in to_remove:
                del self.items[k]
            self._save()
            return len(to_remove)

    def get_stats(self) -> dict:
        """Get queue statistics."""
        with self._lock:
            stats = {status: 0 for status in QUEUE_STATUS}
            for item in self.items.values():
                if item.status in stats:
                    stats[item.status] += 1
            stats["total"] = len(self.items)
            return stats


# =============================================================================
# Processing Logic
# =============================================================================

@dataclass
class ProcessResult:
    """Result of processing a single recording."""
    audio_path: str
    b3sum: str
    success: bool
    steps_completed: list[str] = field(default_factory=list)
    steps_failed: list[str] = field(default_factory=list)
    transcripts: dict[str, str] = field(default_factory=dict)  # backend -> path
    error: Optional[str] = None


def ensure_in_catalog(audio_path: Path, context: Optional[str] = None,
                      dry_run: bool = False, quiet: bool = False) -> bool:
    """Ensure the audio file is in the catalog."""
    speaker_catalog = find_tool("speaker-catalog")
    if not speaker_catalog:
        if not quiet:
            print(f"  Warning: speaker-catalog not found, skipping catalog registration")
        return True  # Continue without catalog

    # Check if already in catalog
    result = subprocess.run(
        [str(speaker_catalog), "status", str(audio_path)],
        capture_output=True,
        text=True,
    )

    if result.returncode == 0:
        # Already in catalog
        return True

    if dry_run:
        if not quiet:
            print(f"  [DRY RUN] Would add to catalog: {audio_path.name}")
        return True

    # Add to catalog
    cmd = [str(speaker_catalog), "add", str(audio_path), "--quiet"]
    if context:
        cmd.extend(["--context", context])

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        if not quiet:
            print(f"  Warning: Failed to add to catalog: {result.stderr.strip()}")
        return False

    return True


def transcribe_with_backend(audio_path: Path, backend: str, output_dir: Path,
                            dry_run: bool = False, quiet: bool = False) -> Optional[Path]:
    """Run transcription with a specific backend."""
    stt_cmd_name = get_stt_command(backend)
    if not stt_cmd_name:
        if not quiet:
            print(f"  Warning: Unknown backend '{backend}'")
        return None

    stt_tool = find_tool(stt_cmd_name)
    if not stt_tool:
        if not quiet:
            print(f"  Warning: STT tool not found for backend '{backend}'")
        return None

    # Build output path
    output_name = f"{audio_path.stem}.{backend}.json"
    output_path = output_dir / output_name

    # Check if already exists
    if output_path.exists():
        if not quiet:
            print(f"  Transcript exists: {output_name}")
        return output_path

    if dry_run:
        if not quiet:
            print(f"  [DRY RUN] Would transcribe with {backend}: {audio_path.name}")
        return output_path

    # Run transcription
    cmd = [str(stt_tool), str(audio_path), "-o", str(output_path)]

    if not quiet:
        print(f"  Transcribing with {backend}...")

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        if not quiet:
            print(f"  Error: {backend} transcription failed: {result.stderr.strip()[:200]}")
        return None

    if output_path.exists():
        if not quiet:
            print(f"  Created: {output_name}")
        return output_path

    return None


def register_transcript_in_catalog(audio_path: Path, transcript_path: Path,
                                   backend: str, dry_run: bool = False,
                                   quiet: bool = False) -> bool:
    """Register a transcript in the catalog."""
    speaker_catalog = find_tool("speaker-catalog")
    if not speaker_catalog:
        return True  # Continue without catalog

    if dry_run:
        if not quiet:
            print(f"  [DRY RUN] Would register transcript: {transcript_path.name}")
        return True

    cmd = [
        str(speaker_catalog), "register-transcript", str(audio_path),
        "--backend", backend,
        "--transcript", str(transcript_path),
        "--quiet",
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        if not quiet:
            print(f"  Warning: Failed to register transcript: {result.stderr.strip()}")
        return False

    return True


def run_speaker_assign(audio_path: Path, transcript_path: Path,
                       context: Optional[str] = None, dry_run: bool = False,
                       quiet: bool = False) -> bool:
    """Run speaker assignment on a transcript."""
    speaker_assign = find_tool("speaker-assign")
    if not speaker_assign:
        if not quiet:
            print(f"  Warning: speaker-assign not found, skipping assignment")
        return True

    if dry_run:
        if not quiet:
            print(f"  [DRY RUN] Would run speaker-assign")
        return True

    cmd = [
        str(speaker_assign), "assign", str(audio_path),
        "--transcript", str(transcript_path),
        "--use-embeddings",
    ]
    if context:
        cmd.extend(["--context", context])
    if quiet:
        cmd.append("--quiet")

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        if not quiet:
            print(f"  Warning: speaker-assign failed: {result.stderr.strip()[:200]}")
        return False

    return True


def process_single(audio_path: Path, backends: list[str],
                   context: Optional[str] = None,
                   output_dir: Optional[Path] = None,
                   skip_existing: bool = False,
                   dry_run: bool = False,
                   quiet: bool = False) -> ProcessResult:
    """Process a single audio file through the pipeline."""
    audio_path = audio_path.resolve()
    b3sum = compute_b3sum(audio_path)

    if output_dir is None:
        output_dir = audio_path.parent

    result = ProcessResult(
        audio_path=str(audio_path),
        b3sum=b3sum,
        success=True,
    )

    if not quiet:
        print(f"\nProcessing: {audio_path.name}")
        print(f"  b3sum: {b3sum[:8]}...")

    # Step 1: Ensure in catalog
    if ensure_in_catalog(audio_path, context, dry_run, quiet):
        result.steps_completed.append("catalog_add")
    else:
        result.steps_failed.append("catalog_add")

    # Step 2: Transcribe with each backend
    first_transcript = None
    for backend in backends:
        transcript_path = transcribe_with_backend(
            audio_path, backend, output_dir, dry_run, quiet
        )
        if transcript_path:
            result.transcripts[backend] = str(transcript_path)
            result.steps_completed.append(f"transcribe_{backend}")
            if first_transcript is None:
                first_transcript = transcript_path

            # Register transcript in catalog
            if register_transcript_in_catalog(audio_path, transcript_path, backend, dry_run, quiet):
                result.steps_completed.append(f"register_{backend}")
            else:
                result.steps_failed.append(f"register_{backend}")
        else:
            result.steps_failed.append(f"transcribe_{backend}")

    # Step 3: Run speaker assignment (use first successful transcript)
    if first_transcript and not dry_run:
        if run_speaker_assign(audio_path, first_transcript, context, dry_run, quiet):
            result.steps_completed.append("speaker_assign")
        else:
            result.steps_failed.append("speaker_assign")

    # Determine overall success
    result.success = len(result.transcripts) > 0

    if not quiet:
        if result.success:
            print(f"  Status: completed ({len(result.transcripts)} transcript(s))")
        else:
            print(f"  Status: failed - {', '.join(result.steps_failed)}")

    return result


def process_batch(items: list[QueueItem], parallel: int = 4,
                  output_dir: Optional[Path] = None,
                  skip_existing: bool = False,
                  dry_run: bool = False,
                  quiet: bool = False) -> list[ProcessResult]:
    """Process a batch of queue items."""
    queue = ProcessingQueue()
    results = []

    def process_item(item: QueueItem) -> ProcessResult:
        """Process a single queue item."""
        queue.update_status(item.b3sum, "processing")

        audio_path = Path(item.audio_path)
        if not audio_path.exists():
            queue.update_status(item.b3sum, "failed", error="Audio file not found")
            return ProcessResult(
                audio_path=item.audio_path,
                b3sum=item.b3sum,
                success=False,
                error="Audio file not found",
            )

        result = process_single(
            audio_path,
            item.backends,
            context=item.context,
            output_dir=output_dir,
            skip_existing=skip_existing,
            dry_run=dry_run,
            quiet=quiet,
        )

        if result.success:
            queue.update_status(
                item.b3sum, "completed",
                results={"transcripts": result.transcripts}
            )
        else:
            queue.update_status(
                item.b3sum, "failed",
                error=result.error or "Processing failed",
                results={"steps_failed": result.steps_failed}
            )

        return result

    if parallel > 1 and len(items) > 1:
        with concurrent.futures.ThreadPoolExecutor(max_workers=parallel) as executor:
            future_to_item = {executor.submit(process_item, item): item for item in items}
            for future in concurrent.futures.as_completed(future_to_item):
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    item = future_to_item[future]
                    queue.update_status(item.b3sum, "failed", error=str(e))
                    results.append(ProcessResult(
                        audio_path=item.audio_path,
                        b3sum=item.b3sum,
                        success=False,
                        error=str(e),
                    ))
    else:
        for item in items:
            try:
                result = process_item(item)
                results.append(result)
            except Exception as e:
                queue.update_status(item.b3sum, "failed", error=str(e))
                results.append(ProcessResult(
                    audio_path=item.audio_path,
                    b3sum=item.b3sum,
                    success=False,
                    error=str(e),
                ))

    return results


# =============================================================================
# Commands
# =============================================================================

def cmd_process(args: argparse.Namespace) -> int:
    """Process recording(s) immediately."""
    input_path = Path(args.path).resolve()

    if not input_path.exists():
        print(f"Error: Path not found: {input_path}", file=sys.stderr)
        return 1

    # Parse backends
    backends = args.backend.split(",") if args.backend else DEFAULT_BACKENDS

    # Find audio files
    if input_path.is_file():
        if not is_audio_file(input_path):
            print(f"Error: Not an audio file: {input_path}", file=sys.stderr)
            return 1
        audio_files = [input_path]
    else:
        audio_files = find_audio_files(input_path, recursive=args.recursive)
        if not audio_files:
            print(f"Error: No audio files found in: {input_path}", file=sys.stderr)
            return 1

    if not args.quiet:
        print(f"Found {len(audio_files)} audio file(s)")
        if args.dry_run:
            print("=== DRY RUN - No changes will be made ===")

    # Create queue items for processing
    queue = ProcessingQueue()
    items = []
    for audio_path in audio_files:
        item = queue.add(audio_path, context=args.context, backends=backends)
        if item:
            items.append(item)

    # Determine output directory
    output_dir = Path(args.output_dir) if args.output_dir else None

    # Process
    results = process_batch(
        items,
        parallel=args.parallel,
        output_dir=output_dir,
        skip_existing=args.skip_existing,
        dry_run=args.dry_run,
        quiet=args.quiet,
    )

    # Summary
    if not args.quiet:
        succeeded = sum(1 for r in results if r.success)
        failed = sum(1 for r in results if not r.success)
        print(f"\n{'='*40}")
        print(f"Summary: {succeeded} succeeded, {failed} failed")

    return 0 if all(r.success for r in results) else 1


def cmd_queue(args: argparse.Namespace) -> int:
    """Add recording(s) to the processing queue."""
    input_path = Path(args.path).resolve()

    if not input_path.exists():
        print(f"Error: Path not found: {input_path}", file=sys.stderr)
        return 1

    # Parse backends
    backends = args.backend.split(",") if args.backend else DEFAULT_BACKENDS

    # Find audio files
    if input_path.is_file():
        if not is_audio_file(input_path):
            print(f"Error: Not an audio file: {input_path}", file=sys.stderr)
            return 1
        audio_files = [input_path]
    else:
        audio_files = find_audio_files(input_path, recursive=args.recursive)
        if not audio_files:
            print(f"Error: No audio files found in: {input_path}", file=sys.stderr)
            return 1

    # Add to queue
    queue = ProcessingQueue()
    added = 0
    for audio_path in audio_files:
        item = queue.add(audio_path, context=args.context, backends=backends)
        if item:
            added += 1
            if not args.quiet:
                print(f"Queued: {audio_path.name} ({item.b3sum[:8]}...)")

    if not args.quiet:
        print(f"\nAdded {added} item(s) to queue")

    return 0


def cmd_status(args: argparse.Namespace) -> int:
    """Show processing queue status."""
    queue = ProcessingQueue()
    stats = queue.get_stats()

    if args.format == "json":
        output = {
            "stats": stats,
            "items": [item.to_dict() for item in queue.items.values()],
        }
        print(json.dumps(output, indent=2, ensure_ascii=False))
        return 0

    # Human-readable output
    print("Processing Queue Status")
    print("=" * 40)
    print(f"  Total items:  {stats['total']}")
    print(f"  Pending:      {stats['pending']}")
    print(f"  Processing:   {stats['processing']}")
    print(f"  Completed:    {stats['completed']}")
    print(f"  Failed:       {stats['failed']}")
    print(f"  Skipped:      {stats['skipped']}")

    if args.verbose and queue.items:
        print("\nQueue Items:")
        for item in queue.items.values():
            audio_name = Path(item.audio_path).name
            print(f"\n  {audio_name}")
            print(f"    b3sum: {item.b3sum[:8]}...")
            print(f"    status: {item.status}")
            print(f"    backends: {', '.join(item.backends)}")
            if item.context:
                print(f"    context: {item.context}")
            if item.error:
                print(f"    error: {item.error[:100]}")
            if item.results:
                print(f"    results: {json.dumps(item.results, indent=6)}")

    return 0


def cmd_run(args: argparse.Namespace) -> int:
    """Run processing on queued items."""
    queue = ProcessingQueue()
    pending = queue.get_pending(limit=args.limit)

    if not pending:
        if not args.quiet:
            print("No pending items in queue")
        return 0

    if not args.quiet:
        print(f"Processing {len(pending)} queued item(s)")
        if args.dry_run:
            print("=== DRY RUN - No changes will be made ===")

    # Determine output directory
    output_dir = Path(args.output_dir) if args.output_dir else None

    # Process
    results = process_batch(
        pending,
        parallel=args.parallel,
        output_dir=output_dir,
        skip_existing=args.skip_existing,
        dry_run=args.dry_run,
        quiet=args.quiet,
    )

    # Summary
    if not args.quiet:
        succeeded = sum(1 for r in results if r.success)
        failed = sum(1 for r in results if not r.success)
        print(f"\n{'='*40}")
        print(f"Summary: {succeeded} succeeded, {failed} failed")

    return 0 if all(r.success for r in results) else 1


def cmd_clear_queue(args: argparse.Namespace) -> int:
    """Clear the processing queue."""
    queue = ProcessingQueue()

    if not args.force:
        stats = queue.get_stats()
        print(f"Clear {stats['total']} item(s) from queue?")
        if args.status:
            print(f"  (filtering by status: {args.status})")
        response = input("Confirm [y/N]: ")
        if response.lower() != "y":
            print("Cancelled")
            return 0

    cleared = queue.clear(status_filter=args.status)
    if not args.quiet:
        print(f"Cleared {cleared} item(s) from queue")

    return 0


# =============================================================================
# Main
# =============================================================================

def main() -> int:
    parser = argparse.ArgumentParser(
        description="Batch recording processing orchestrator",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Process a single recording
  speaker-process process meeting.mp3

  # Process all recordings in a directory
  speaker-process process ./recordings/ --recursive

  # Process with specific backends
  speaker-process process meeting.mp3 --backend speechmatics,assemblyai

  # Add to queue for later processing
  speaker-process queue ./recordings/ --context team-standup

  # Run queued processing
  speaker-process run --parallel 4

  # Check queue status
  speaker-process status
""",
    )
    parser.add_argument("-V", "--version", action="version", version=f"speaker-process {VERSION}")
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress non-essential output")

    subparsers = parser.add_subparsers(dest="command", required=True)

    # process command
    process_parser = subparsers.add_parser("process", help="Process recording(s) immediately")
    process_parser.add_argument("path", help="Path to audio file or directory")
    process_parser.add_argument("--backend", "-b", help=f"Comma-separated backends (default: {','.join(DEFAULT_BACKENDS)})")
    process_parser.add_argument("--context", "-c", help="Context name for new recordings")
    process_parser.add_argument("--parallel", "-p", type=int, default=4, help="Number of parallel jobs (default: 4)")
    process_parser.add_argument("--output-dir", "-o", help="Output directory for transcripts")
    process_parser.add_argument("--recursive", "-r", action="store_true", help="Recursively scan directories")
    process_parser.add_argument("--skip-existing", "-s", action="store_true", help="Skip already processed recordings")
    process_parser.add_argument("--dry-run", "-n", action="store_true", help="Show what would run without executing")
    process_parser.set_defaults(func=cmd_process)

    # queue command
    queue_parser = subparsers.add_parser("queue", help="Add recording(s) to processing queue")
    queue_parser.add_argument("path", help="Path to audio file or directory")
    queue_parser.add_argument("--backend", "-b", help=f"Comma-separated backends (default: {','.join(DEFAULT_BACKENDS)})")
    queue_parser.add_argument("--context", "-c", help="Context name for new recordings")
    queue_parser.add_argument("--recursive", "-r", action="store_true", help="Recursively scan directories")
    queue_parser.set_defaults(func=cmd_queue)

    # status command
    status_parser = subparsers.add_parser("status", help="Show processing queue status")
    status_parser.add_argument("--format", "-f", choices=["text", "json"], default="text")
    status_parser.add_argument("-v", "--verbose", action="store_true", help="Show detailed item info")
    status_parser.set_defaults(func=cmd_status)

    # run command
    run_parser = subparsers.add_parser("run", help="Run processing on queued items")
    run_parser.add_argument("--limit", "-l", type=int, help="Maximum number of items to process")
    run_parser.add_argument("--parallel", "-p", type=int, default=4, help="Number of parallel jobs (default: 4)")
    run_parser.add_argument("--output-dir", "-o", help="Output directory for transcripts")
    run_parser.add_argument("--skip-existing", "-s", action="store_true", help="Skip already processed recordings")
    run_parser.add_argument("--dry-run", "-n", action="store_true", help="Show what would run without executing")
    run_parser.set_defaults(func=cmd_run)

    # clear-queue command
    clear_parser = subparsers.add_parser("clear-queue", help="Clear the processing queue")
    clear_parser.add_argument("--status", "-s", choices=QUEUE_STATUS, help="Only clear items with this status")
    clear_parser.add_argument("--force", "-f", action="store_true", help="Skip confirmation")
    clear_parser.set_defaults(func=cmd_clear_queue)

    args = parser.parse_args()
    return args.func(args)


if __name__ == "__main__":
    sys.exit(main())
